# os_from_scratch
Fresh start of os_dev using https://github.com/cfenollosa/os-tutorial

## 10-kernel-c

### GOAL: Write some low level code in C
#### Compile
Compile C code and compare to the code generated by assembler.

We will start with writing a simple program containing a function, `function.c`

To compile system indepent code, we need the flag `-ffreestanding`

`i386-elf-gcc -ffreestanding -c cuntion.c -o function.o`

Examine the machine code

`i386-elf-objdump -d function.o`

##### Link
Finally, to produce a binary file, we will use the linker. An important part of this step is to learn how high level languages call function labels. Which is the offset where our function will be placed in memory? We don't actually know. For this example, we'll place the offset at `0x0` and use the `binary` format which generates machine code without any labels and/or metadata

`i386-elf-ld -o function.bin -Ttext 0x0 --oformat binary function.o`

Note: a warning may appear when linking, disregard it

Now examine both "binary" files, `function.o` and `function.bin` using xxd. You will see that the `.bin` file is machine code, while the `.o` file has a lot of debugging information, labels, etc.

##### Decompile
As a curiousity, examine the machine code

`ndisasm -b 32 function.bin`

#####More
I encourage you to write more small programs, which feature:

 * Local variables localvars.c
 * Function calls functioncalls.c
 * Pointers pointers.c

Then compile and disassemble them, and examine the resulting machine code. Follow the os-guide.pdf for explanations. Try to answer this question: why does the disassemblement of `pointers.c` not resemble what you would expect? Where is the ASCII `0x48656c6c6f` for "Hello"?


### Notes
